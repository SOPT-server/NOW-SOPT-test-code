## 주의사항

1. 초반부터 복잡한 테스트부터 시작하면 안된다.
    1. 개발자 자신도 모르게 버그를 만들고, 이를 해결하기 위해 시간을 허비할 수 있다.
    2. 테스트 통과 시간이 길어진다.
    3. 코드 작성 시간이 길어져 집중력이 떨어지고, 흐름이 끊길 수 있다.
2. 가장 구현하기 쉬운 테스트부터 작성할 것
    1. 이 과정에서 어떤 것이 더 구현하기 쉬울지 골라야한다. 짧은 시간에 구현할 수 있는 테스트를 선택해야한다.
    2. 디버깅하기 쉽고 단순하다는 장점이 있다. 버그를 잡아내기 매우 편리하다.
3. 예외 상황을 먼저 테스트한다.
    1. 예외 상황을 나중에 추가하면 코드를 갈아엎거나, 중간에 조건문을 추가하는 일이 벌어지는데 이는 예상치 못한 버그의 원인이 됨
    2. 미리 예외상황을 추가해놓으면 코드 구조를 덜 바꿀 수 있고, 버그를 방지할 수 있음

## 테스트 코드 작성 순서

아래와 같은 순서로 TDD를 작성하도록 하자.

1. 정해진 값을 리턴
2. 값 비교를 이용해서 정해진 값을 리턴
3. 다양한 테스트를 추가하면서 구현을 일반화

아래는 예시이다.

1. 길이가 8글자 미만이지만 나머지 규칙은 통과 ex) `ab12!@A`

```java
@Test
void meetsOtherCreteria_except_for_Length_Then_Normal() {
	PasswordStrengthMeter = meter = new PasswordStrengthMeter();
	PasswordStrength result = meter.meter("ab12!@A");
	assertEquals(PasswordStrength.NORMAL, result);

}
```

```java
public class PasswordStrengthMeter {
	public PasswordStrength meter(String s){
		if ("ab12!@A".equals(s))
			return PasswordStrength.NORMAL;
		return PasswordStrength.STRONG;
	}
}
```

1. 1-1에 동일한 조건을 검증하기 위한 예시를 추가 ex) `Ab12!c`

```java
@Test
void meetsOtherCreteria_except_for_Length_Then_Normal() {
	PasswordStrengthMeter = meter = new PasswordStrengthMeter();
	PasswordStrength result = meter.meter("ab12!@A");
	assertEquals(PasswordStrength.NORMAL, result);

}
```

여기서 `Ab12!c` 을 통과하기 위해선 아래와 같은 코드를 추가할 수 있다.

```java
public class PasswordStrengthMeter {
	public PasswordStrength meter(String s){
		if ("ab12!@A".equals(s) || "Ab12!c".equals(s))
			return PasswordStrength.NORMAL;
		return PasswordStrength.STRONG;
	}
}
```

1. 상수를 제거하고 일반화하기

```java
public class PasswordStrengthMeter {
	public PasswordStrength meter(String s){
		if (s.length() < 8)
			return PasswordStrength.NORMAL;
		return PasswordStrength.STRONG;
	}
}
```

위와 같은 흐름으로 특정 테스트 케이스 추가 → 일반화의 과정으로 점진적으로 TDD를 작성하는 연습을 해야한다.

## 테스트 통과 후 : 리팩토링

위와 같이 테스트 코드를 추가하는 사이클을 거친 뒤 리팩토링을 진행한다. 이는 매번 필수는 아니고, 코드 중복과 같이 적절한 대상이 생기면 진행하면 된다. 중복되는 부분은 메서드로 빼버려 적절한 이름을 정해주자.

이 때 메서드 추출은 구현 흐름이 명확해졌을 때 진행해야한다.구현 흐름이 모호한 상태에서 진행하면 코드 구조를 잘 못 잡을 가능성이 있고, 다음 구현이 어려워질 수 있다.

리팩토링은 코드 가독성이 높아지고, 개발자가 더욱 빠르게 코드를 분석하고 유지보수가 수월해 진다는 장점이 있다.